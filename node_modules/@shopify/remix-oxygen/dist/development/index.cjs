'use strict';

var reactRouter = require('react-router');

// src/server.ts

// src/event-logger.ts
var hasWarned = false;
function createEventLogger(appLoadContext) {
  const context = appLoadContext || {};
  const eventLoggerService = context?.env?.H2O_LOG_EVENT;
  if (typeof eventLoggerService?.fetch !== "function") return;
  return ({
    url,
    endTime = Date.now(),
    waitUntil = context?.waitUntil,
    ...rest
  }) => {
    const promise = Promise.resolve().then(
      () => eventLoggerService.fetch(
        new Request(url, {
          method: "POST",
          body: JSON.stringify({
            endTime,
            ...rest
          })
        })
      ).catch((error) => {
        if (!hasWarned) {
          console.debug("Failed to log H2O event\n", error.stack);
          hasWarned = true;
        }
      })
    );
    promise && waitUntil?.(promise);
  };
}

// src/server.ts
var originalErrorToString = Error.prototype.toString;
Error.prototype.toString = function() {
  return this.stack || originalErrorToString.call(this);
};
function createRequestHandler({
  build,
  mode,
  poweredByHeader = true,
  getLoadContext
}) {
  const handleRequest = reactRouter.createRequestHandler(build, mode);
  return async (request) => {
    const method = request.method;
    if ((method === "GET" || method === "HEAD") && request.body) {
      return new Response(`${method} requests cannot have a body`, {
        status: 400
      });
    }
    const url = new URL(request.url);
    if (url.pathname.includes("//")) {
      return new Response(null, {
        status: 301,
        headers: {
          location: url.pathname.replace(/\/+/g, "/")
        }
      });
    }
    const context = getLoadContext ? await getLoadContext(request) : void 0;
    if (context) {
      globalThis.__H2O_LOG_EVENT ??= createEventLogger(context);
    }
    const startTime = Date.now();
    const response = await handleRequest(request, context);
    if (poweredByHeader) {
      response.headers.append("powered-by", "Shopify, Hydrogen");
    }
    {
      globalThis.__H2O_LOG_EVENT?.({
        eventType: "request",
        url: request.url,
        requestId: request.headers.get("request-id"),
        purpose: request.headers.get("purpose"),
        startTime,
        responseInit: {
          status: response.status,
          statusText: response.statusText,
          headers: Array.from(response.headers.entries())
        }
      });
    }
    return response;
  };
}
function getStorefrontHeaders(request) {
  const headers = request.headers;
  return {
    requestGroupId: headers.get("request-id"),
    buyerIp: headers.get("oxygen-buyer-ip"),
    cookie: headers.get("cookie"),
    purpose: headers.get("purpose")
  };
}

Object.defineProperty(exports, "createCookie", {
  enumerable: true,
  get: function () { return reactRouter.createCookie; }
});
Object.defineProperty(exports, "createCookieSessionStorage", {
  enumerable: true,
  get: function () { return reactRouter.createCookieSessionStorage; }
});
Object.defineProperty(exports, "createMemorySessionStorage", {
  enumerable: true,
  get: function () { return reactRouter.createMemorySessionStorage; }
});
Object.defineProperty(exports, "createSession", {
  enumerable: true,
  get: function () { return reactRouter.createSession; }
});
Object.defineProperty(exports, "createSessionStorage", {
  enumerable: true,
  get: function () { return reactRouter.createSessionStorage; }
});
Object.defineProperty(exports, "data", {
  enumerable: true,
  get: function () { return reactRouter.data; }
});
Object.defineProperty(exports, "isCookie", {
  enumerable: true,
  get: function () { return reactRouter.isCookie; }
});
Object.defineProperty(exports, "isSession", {
  enumerable: true,
  get: function () { return reactRouter.isSession; }
});
Object.defineProperty(exports, "redirect", {
  enumerable: true,
  get: function () { return reactRouter.redirect; }
});
Object.defineProperty(exports, "redirectDocument", {
  enumerable: true,
  get: function () { return reactRouter.redirectDocument; }
});
exports.createRequestHandler = createRequestHandler;
exports.getStorefrontHeaders = getStorefrontHeaders;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map